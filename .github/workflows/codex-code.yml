name: Codex Full Auto (Final and Generic)

on:
  workflow_dispatch:
    inputs:
      CODEX_PROMPT:
        description: 'The main instruction/prompt for the AI.'
        required: true
        default: 'Create a simple placeholder file.'
      TICKET_ID:
        description: 'The Jira/Ticket ID for branch naming and commits.'
        required: true
        default: 'default-ticket-id'
      CODEX_MODEL:
        description: 'The AI model to use (e.g., o3, gpt-4-turbo).'
        required: true
        default: 'gpt-5'
      JIRA_IMAGE_URLS:
        description: 'Comma-separated list of image URLs from Jira.'
        required: false
      JIRA_IMAGE_FILENAMES:
        description: 'Comma-separated list of original image filenames from Jira.'
        required: false
  repository_dispatch:
    types: [codex-run]

jobs:
  codex-full-auto:
    runs-on: ubuntu-latest
    container: node:latest

    env:
      # Secrets for operation
      FIGMA_ACCESS_TOKEN: ${{ secrets.FIGMA_ACCESS_TOKEN }}
      OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
      N8N_MR_WEBHOOK_URL: ${{ secrets.N8N_PR_WEBHOOK_URL }}
      CODEX_PUSH_TOKEN: ${{ secrets.CODEX_PUSH_TOKEN }}
      
      # Inputs from dispatch events
      CODEX_PROMPT: |
        ${{ github.event.inputs.CODEX_PROMPT || github.event.client_payload.CODEX_PROMPT }}
      TICKET_ID: ${{ github.event.inputs.TICKET_ID || github.event.client_payload.TICKET_ID }}
      CODEX_MODEL: ${{ github.event.inputs.CODEX_MODEL || github.event.client_payload.CODEX_MODEL }}
      JIRA_IMAGE_URLS: ${{ github.event.inputs.JIRA_IMAGE_URLS || github.event.client_payload.JIRA_IMAGE_URLS }}
      JIRA_IMAGE_FILENAMES: ${{ github.event.inputs.JIRA_IMAGE_FILENAMES || github.event.client_payload.JIRA_IMAGE_FILENAMES }}
      
      # Repository context
      GH_REPO: ${{ github.repository }}
      DEFAULT_BRANCH: ${{ github.event.repository.default_branch }}

    steps:
      - name: 1. Install System Dependencies
        run: |
          apt-get update -y && apt-get install -y --no-install-recommends curl jq sed file
      - name: 2. Checkout Repository
        uses: actions/checkout@v4
        with:
          token: ${{ env.CODEX_PUSH_TOKEN }}
          fetch-depth: 0
      - name: 3. Configure Git and Install Codex CLI
        run: |
          git config --global user.name "GitHub Actions Bot"
          git config --global user.email "actions-bot@github.com"
          npm install -g @openai/codex
          
      - name: 4. Create Codex Config for Figma MCP
        # This crucial step configures the Figma connection on every run
        if: env.FIGMA_ACCESS_TOKEN != ''
        run: |
          echo "Setting up Figma MCP server for Codex CLI..."
          mkdir -p ~/.codex
          cat <<EOF > ~/.codex/config.toml
          [mcp_servers.figma]
          command = "npx"
          args = ["-y", "figma-developer-mcp", "--figma-api-key=${FIGMA_ACCESS_TOKEN}", "--stdio"]
          EOF
          echo "Codex config for Figma MCP created successfully. Verifying content:"
          cat ~/.codex/config.toml

      - name: 5. Install Project Dependencies
        run: npm install
        
      - name: 6. Set Workspace Permissions for Non-Root User
        run: |
          chown -R node:node "$GITHUB_WORKSPACE"

      - name: 7. Execute Main AI, Build, and Git Logic
        id: main_script
        shell: bash
        run: |
          git config --global --add safe.directory "$GITHUB_WORKSPACE"
          FEATURE_BRANCH_NAME="feature/$TICKET_ID"
          git checkout -b "$FEATURE_BRANCH_NAME" "origin/$DEFAULT_BRANCH"
          
          FINAL_PROMPT="${CODEX_PROMPT}${DEMO_DATA_PROMPT}"
          CODEX_CMD_ARGS=("--full-auto" "-m" "$CODEX_MODEL")
          
          # This command now automatically uses the Figma MCP server whenever a figma.com URL is in the prompt
          codex exec "${CODEX_CMD_ARGS[@]}" "$FINAL_PROMPT"
          
          rm -f jira_dl_image_*
          echo "Compiling EDS Models..."
          npm run build:json
          echo "EDS Models build completed."
          
          if [ -n "$(git status --porcelain)" ]; then
            git add -A
            git commit -m "feat($TICKET_ID): Apply AI-generated changes [skip ci]"
            git push -u origin "$FEATURE_BRANCH_NAME"
            echo "changes_pushed=true" >> $GITHUB_OUTPUT
          else
            echo "No file changes detected."
            echo "changes_pushed=false" >> $GITHUB_OUTPUT
          fi

      - name: 8. Wait for EDS Deployment
        if: steps.main_script.outputs.changes_pushed == 'true'
        run: "sleep 10"
     
      - name: 9. Notify N8N to Create Pull Request
        if: steps.main_script.outputs.changes_pushed == 'true'
        shell: bash
        run: |
          set -euo pipefail

          FEATURE_BRANCH_NAME="feature/$TICKET_ID"
          LATEST_COMMIT_SHA=$(git rev-parse HEAD)
          REPO_OWNER=$(echo "$GH_REPO" | cut -d'/' -f1)
          REPO_NAME=$(echo "$GH_REPO" | cut -d'/' -f2)
          SANITIZED_BRANCH_NAME=$(echo "$FEATURE_BRANCH_NAME" | sed 's/\//-/g')
          REPO_OWNER_FORK="comwrap"
          PREVIEW_URL="https://$SANITIZED_BRANCH_NAME--$REPO_NAME--$REPO_OWNER_FORK.hlx.page"
          PR_TITLE="feat($TICKET_ID): Implement feature $TICKET_ID (AI Assisted)"

          PR_BODY=$(cat <<EOF
          This Pull Request was automatically generated by the Codex AI Developer to implement ticket **$TICKET_ID**.
          ### URL for testing:
          - $PREVIEW_URL
          Commit SHA: \`$LATEST_COMMIT_SHA\`
          EOF
          )

          JSON_PAYLOAD=$(jq -n \
            --arg fb "$FEATURE_BRANCH_NAME" \
            --arg tb "$DEFAULT_BRANCH" \
            --arg tid "$TICKET_ID" \
            --arg commitSha "$LATEST_COMMIT_SHA" \
            --arg repo "$GH_REPO" \
            --arg prTitle "$PR_TITLE" \
            --arg prBody "$PR_BODY" \
            '{source_branch: $fb, target_branch: $tb, ticket_id: $tid, commit_sha: $commitSha, repo: $repo, pull_request_title: $prTitle, pull_request_body: $prBody}')

          if [ -z "${N8N_MR_WEBHOOK_URL:-}" ]; then
            echo "Warning: N8N_PR_WEBHOOK_URL secret is not set."
            WEBHOOK_STATUS=""
          else
            WEBHOOK_STATUS=$(curl -s -w "%{http_code}" -o /tmp/pr_webhook_response.txt \
              -X POST -H "Content-Type: application/json" \
              -d "$JSON_PAYLOAD" "$N8N_MR_WEBHOOK_URL" || true)
            echo "Webhook HTTP status: $WEBHOOK_STATUS"
            if [[ "$WEBHOOK_STATUS" =~ ^2 ]]; then
              echo "Webhook PR creation succeeded."
              exit 0
            else
              echo "Webhook call failed. Response body:"
              cat /tmp/pr_webhook_response.txt || true
            fi
          fi

          echo "Falling back to creating PR directly on GitHub..."
          GH_API_URL="https://api.github.com/repos/$GH_REPO/pulls"
          GH_PAYLOAD=$(jq -n \
            --arg title "$PR_TITLE" \
            --arg head "$FEATURE_BRANCH_NAME" \
            --arg base "$DEFAULT_BRANCH" \
            --arg body "$PR_BODY" \
            '{title: $title, head: $head, base: $base, body: $body}')

          GH_STATUS=$(curl -s -w "%{http_code}" -o /tmp/gh_pr_response.json \
            -X POST \
            -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
            -H "Accept: application/vnd.github+json" \
            -d "$GH_PAYLOAD" "$GH_API_URL" || true)
          echo "GitHub API HTTP status: $GH_STATUS"
          echo "GitHub API response:"
          cat /tmp/gh_pr_response.json || true
          if [[ ! "$GH_STATUS" =~ ^2 ]]; then
            echo "Error: Failed to create PR via GitHub API." >&2
            exit 1
          fi
