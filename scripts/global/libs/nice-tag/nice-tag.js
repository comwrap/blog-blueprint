/**
 * CSS loading function for {@link NiceTag}.
 */
export const loadCSS = async () => import(`${window.hlx.codeBasePath}/scripts/aem.js`)
  .then((mod) => mod.loadCSS(`${window.hlx.codeBasePath}/scripts/global/libs/nice-tag/nice-tag.css`));

export const NICE_TAG_CLASS = 'nice-tag';

/**
 * An accessible, reusable “tag” toggle component implemented as a checkbox with a labeled
 * button-like UI.
 * It manages keyboard interaction, ARIA attributes, visual selected/disabled states, and dispatches
 * an enhanced input event for easier integration.
 *
 * The component renders:
 * - A wrapper element (role="group") with state classes
 *   (e.g., `nice-tag--selected`, `nice-tag--disabled`).
 * - A hidden checkbox `<input type="checkbox">` holding the tag's value and
 *   constraint-validation state.
 * - A `<label>` acting as the interactive button, linked to the input via `for`/`id`.
 *
 * ### Features
 * - Generates a unique ID for the input/label when none is provided.
 * - Click or keyboard (Space/Enter) toggles selection, keeping UI and state in sync.
 * - Dispatches a bubbling `nice-input` CustomEvent with
 *   `{ name, label, value, selected, validity }`.
 * - Syncs ARIA attributes for required/disabled/readonly on both input and wrapper.
 * - Simple programmatic control via setters for `selected`, `disabled`, `required`, and `readonly`.
 *
 * ### Types
 * @typedef {import('./types').NiceTagOptions} NiceTagOptions
 * The configuration object used to initialize the component.
 *
 * Expected fields include:
 * - `name?: string` – Form/control name used in events and native form submission.
 * - `label?: string` – Visible label text.
 * - `value?: string` – Underlying value of the tag (submitted if selected).
 * - `selected?: boolean` – Initial selected state.
 * - `required?: boolean` – Whether selection is required.
 * - `disabled?: boolean` – Initial disabled state.
 * - `readonly?: boolean` – Read-only state (focusable but not changeable).
 * - `id?: string` – Custom ID for the input; autogenerated if omitted.
 * - `className?: string` – Extra CSS class(es) applied to the root wrapper.
 * - `form?: string` – Associated form ID for the input element.
 *
 * ### Usage
 * ```js
 * import NiceTag from './NiceTag.js';
 *
 * const tag = new NiceTag({
 *   name: 'name',
 *   label: 'Label',
 *   value: 'value',
 *   selected: true,
 * });
 *
 * document.body.appendChild(tag.element);
 *
 * tag.addEventListener('nice-input', (e) => {
 *   const { name, label, value, selected, validity } = e.detail;
 *   console.log(name, label, value, selected, validity.valid);
 * });
 * ```
 *
 * ### Events
 * - `nice-input` (bubbles): dispatched whenever the internal checkbox value changes,
 *   either via mouse, keyboard, or programmatic toggle followed by a synthetic input.
 *   Detail payload: `{ name, label, value, selected, validity }`.
 *
 * ### Accessibility
 * - Wrapper uses `role="group"` and mirrors `aria-disabled`, `aria-required`, `aria-readonly`.
 * - Input reflects `required`, `disabled`, `readOnly`, and corresponding ARIA attributes.
 * - Keyboard: Space/Enter on the wrapper toggles selection and triggers an input event.
 *
 * ### Public API
 * - `element: HTMLElement` → Root element to insert into the DOM.
 * - `name: string` → Read-only control name.
 * - `label: string` → Read-only visible label text.
 * - `value: string` → Read-only underlying value.
 * - `selected: boolean` → Get/set current selected state.
 * - `disabled: boolean` → Get/set disabled state (updates ARIA and focusability).
 * - `required: boolean` → Get/set required state (updates ARIA).
 * - `readonly: boolean` → Get/set read-only state (updates ARIA).
 * - `validity: ValidityState` → Native validity object of the underlying input.
 * - `enable()` / `disable()` → Convenience methods to toggle disabled state.
 * - `setSelected(selected: boolean)` → Programmatically set selection
 *   (does not dispatch by itself).
 * - `setRequired(required: boolean)`, `setReadOnly(readonly: boolean)`,
 *   `setDisabled(disabled: boolean)` → State setters that keep ARIA in sync.
 * - `addEventListener(type, listener, options)` → Attach listeners to the root wrapper.
 *
 * @class NiceTag
 * @classdesc An accessible, keyboard-friendly toggle tag built on a checkbox + label,
 * dispatching a normalized `nice-input` event and keeping visual, ARIA, and constraint states in
 * sync.
 *
 * @param {NiceTagOptions} options Configuration for name, label, value, initial state, and styling.
 */
export default class NiceTag {
  static #id = 0;

  static get id() {
    const id = NiceTag.#id;
    this.#id += 1;
    return id;
  }

  /** @type {HTMLElement} The tag root element */
  #root;

  /** @type {import("./types").NiceTagOptions} The tag options */
  #options;

  /** @type {HTMLInputElement} The tag input element */
  #input;

  /** @type {HTMLLabelElement} The tag label element (acting as a button) */
  #button;

  /** @type {HTMLSpanElement} The tag label node */
  #labelNode;

  /**
   * @param {import("./types").NiceTagOptions} options Configuration for name, label, value,
   *                                                   initial state, and disabled state.
   */
  constructor(options) {
    /** @type {import("./types").NiceTagOptions} */
    this.#options = {
      name: options?.name ?? '',
      label: options?.label ?? '',
      value: options?.value ?? '',
      selected: Boolean(options?.selected),
      required: Boolean(options?.required),
      disabled: Boolean(options?.disabled),
      readonly: Boolean(options?.readonly),
      id: options?.id || `nice-tag-${NiceTag.id}`,
      className: options?.className ?? '',
    };

    this.#root = document.createRange().createContextualFragment(`
      <div
        class="${NICE_TAG_CLASS} ${this.#options.className ?? ''}"
        role="group"
      >
        <input
          id="${this.#options.id}"
          name="${this.#options.name}"
          type="checkbox"
          value="${this.#options.value}"
          class="nice-tag-input"
          tabindex="-1"
          autocomplete="off"
          ${this.#options.form ? `form="${this.#options.form}"` : ''}
        >
        <label
          for="${this.#options.id}"
          class="nice-tag-button"
        >
          <span class="nice-tag-label">${this.#options.label ?? ''}</span>
        </label>
      </div>
    `).firstElementChild;
    this.#input = this.#root.querySelector(':scope input');
    this.#button = this.#root.querySelector(':scope label');
    this.#labelNode = this.#root.querySelector(':scope label > span:first-child');

    // Initial state
    this.#input.checked = this.#options.selected;
    this.#setSelectedClass(this.#options.selected);
    this.setRequired(this.#options.required);
    this.setDisabled(this.#options.disabled);
    this.setReadOnly(this.#options.readonly);

    this.#addEventListeners();
  }

  /** @private */
  #addEventListeners() {
    // Keyboard support on wrapper (Enter/Space to toggle)
    this.#setupKeyboard();

    // Intercept native input and re-dispatch with detail
    this.#input.addEventListener('input', this.#onNativeInput.bind(this));
  }

  /**
   * Dispatches a bubbling `CustomEvent('nice-input')` from the root with detail
   * `{ name, label, value, selected, validity }`.
   * @private
   */
  #dispatchNiceInput() {
    const detail = {
      name: this.name,
      label: this.label,
      value: this.value,
      selected: this.selected,
      validity: this.validity,
    };
    const forwarded = new CustomEvent('nice-input', {
      bubbles: true,
      cancelable: false,
      detail,
    });
    this.#root.dispatchEvent(forwarded);
  }

  /**
   * Handles incoming native input events.
   * @private
   * @type {(e: Event) => void}
   */
  // eslint-disable-next-line no-unused-vars
  #onNativeInput = (e) => {
    this.#setSelectedClass(this.selected);
    this.#dispatchNiceInput();
  };

  /**
   * Sets or removes the selected modifier class on the root element.
   * @private
   * @param {boolean} selected
   */
  #setSelectedClass(selected) {
    this.#root.classList.toggle('nice-tag--selected', Boolean(selected));
  }

  /**
   * Applies disabled state to the input and root wrapper, and updates ARIA.
   * @private
   * @param {boolean} disabled
   */
  setDisabled(disabled) {
    this.#input.disabled = Boolean(disabled);
    this.#input.setAttribute('aria-disabled', String(disabled));
    this.#root.classList.toggle('nice-tag--disabled', this.#input.disabled);
    // Make the wrapper focusable only when enabled
    if (this.#input.disabled) {
      this.#root.removeAttribute('tabindex');
    } else {
      this.#root.setAttribute('tabindex', '0');
    }
  }

  /**
   * Adds keyboard support on the wrapper: Space/Enter toggles the checkbox.
   * Ensures button-like behavior even if focus is on the wrapper.
   * @private
   */
  #setupKeyboard() {
    // Make wrapper focusable when enabled
    if (!this.#input.disabled) {
      this.#root.setAttribute('tabindex', '0');
    }

    this.#root.addEventListener('keydown', (e) => {
      if (this.#input.disabled) return;
      const isActivationKey = e.key === ' ' || e.key === 'Spacebar' || e.key === 'Enter';
      if (!isActivationKey) return;

      e.preventDefault();
      // Toggle the checkbox; this will emit native 'input' which we intercept
      this.#input.checked = !this.#input.checked;
      // Dispatch native-like 'input' to ensure consistency when toggled via keyboard on wrapper
      const nativeInput = new Event('input', { bubbles: true });
      this.#input.dispatchEvent(nativeInput);
    });
  }

  /**
   * Returns the tag's string value.
   * @returns {string}
   */
  get value() {
    return this.#options.value;
  }

  /**
   * Sets the selected state.
   *
   * NOTE: Does not dispatch an input event automatically; call programmatically if you need to
   * notify listeners.
   * @param {boolean} selected
   */
  setSelected(selected) {
    const next = Boolean(selected);
    if (this.#input.checked !== next) {
      this.#input.checked = next;
      this.#setSelectedClass(next);
      // Keep ARIA/state in sync if any future attributes depend on selection.
    }
  }

  /** @param {boolean} selected */
  set selected(selected) {
    this.setSelected(selected);
  }

  /**
   * Returns the current selected state.
   * @returns {boolean}
   */
  get selected() {
    return this.#input.checked;
  }

  /**
   * Returns the tag label.
   * @returns {string}
   */
  get label() {
    return this.#options.label;
  }

  /**
   * Enables the tag (makes it interactive).
   */
  enable() {
    this.disabled = false;
  }

  /**
   * Disables the tag (makes it non-interactive).
   */
  disable() {
    this.disabled = true;
  }

  /** @param {boolean} disabled */
  set disabled(disabled) {
    this.setDisabled(disabled);
  }

  /**
   * Returns whether the tag is disabled.
   * @returns {boolean}
   */
  get disabled() {
    return this.#input.disabled;
  }

  /**
   * Wraps adding an event listener to the root element.
   * @param {K extends keyof HTMLElementEventMap} type
   * @param {EventListenerOrEventListenerObject} listener
   * @param {boolean | AddEventListenerOptions} options
   */
  addEventListener(type, listener, options) {
    this.#root.addEventListener(type, listener, options);
  }

  get element() {
    return this.#root;
  }

  get name() {
    return this.#options.name;
  }

  get validity() {
    return this.#input.validity;
  }

  /** @param {boolean} required */
  setRequired(required) {
    this.#input.required = Boolean(required);
    this.#input.setAttribute('aria-required', String(this.#input.required));
  }

  /** @param {boolean} required */
  set required(required) {
    this.setRequired(required);
  }

  get required() {
    return this.#input.required;
  }

  /** @param {boolean} readonly */
  setReadOnly(readonly) {
    this.#input.readOnly = Boolean(readonly);
    this.#input.setAttribute('aria-readonly', String(this.#input.readOnly));
  }

  /** @param {boolean} readonly */
  set readonly(readonly) {
    this.setReadOnly(readonly);
  }

  get readonly() {
    return this.#input.readonly;
  }
}
